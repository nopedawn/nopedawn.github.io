---
title: "squ1rrel CTF 2024"
description: ""
summary: ""
date: 2024-05-04T22:00:00+07:00
lastmod: 2024-05-07T22:00:00+07:00
draft: false
menu:
  posts:
    parent: ""
    identifier: "squ1rrelctf-2024"
weight: 910
toc: true
seo:
  title: "" # custom title (optional)
  description: "" # custom description (recommended)
  canonical: "" # custom canonical URL (optional)
  noindex: false # false (default) or true
---


[https://ctftime.org/event/2370](https://ctftime.org/event/2370)

<br>
<p align="center">
  <a href="https://ctf.bsidessf.net/challenges" target="_blank">
    <img src="https://ctftime.org/media/cache/a2/ca/a2ca37513a88a10990af90dda9fe285c.png">
  </a>
</p>

<br>

## CHALL'S SOLVED

| Category | Challenge                                           |
| -------- | --------------------------------------------------- |
| Crypto   | [Lazy RSA](#lazy-rsa)                               |
| Crypto   | [RSA RSA RSA](#rsa-rsa-rsa)                         |
| Misc     | [rainbolt0](#rainbolt0)                             |
| Rev      | [Secret Coffee Nut Stash](#secret-coffee-nut-stash) |
| Rev      | [PYC Fun](#pyc-fun)                                 |

<br>

## Crypto

### Lazy RSA

<details>
  <summary>Overview</summary>

  > Description: Generating primes is too hard, but I did find a couple posted online!  <br>
  
  [lazyrsa.txt](https://github.com/nopedawn/CTF/main/squ1rrelCTF24/Lazy_RSA/lazyrsa.txt) <br>

</details>

The most common RSA challenges:

- n: the modulus for both the public and private keys
- e: the public exponent
- ct: the ciphertext want to decrypt


```yml
n: 23690620655271165329693230765997410033604713853187305472268813793031152348107488119317901392104240429826482611449247251262846508667797483465355228800439339041030982259847598574606272955688345490638311164838117491821117626835340577511562130640807587611523935604871183668968359720411023759980144229161581597397061850707647104033348795132205561234674677139395868595692235525931999596382758921793937149945229459379437008216713404350896206374483356969246476531491049930769999387038678280465689487577291475554699094024761030833540509263174840007922218340417888061099317752496279552046029470370474619439450870110783844218281
e: 65537
ct: 11420169733597912638453974310976296342840438772934899653944946284527921765463891354182152294616337665313108085636067061251485792996493148094827999964385583364992542843630846911864602981658349693548380259629884212903554470004231160866680745154066318419977485221228944716844036265911222656710479650139274719426252576406561307088938784324291655853920727176132853663822020880574204790442647169649094846806057218165102873847070323190392619997632103724159815363319643022552432448214770378596825200154298562513279104608157870845848578603703757405758227316242247843290673221718467366000253484278487854736033323783510299081405
```

We will factor `{n}` into two prime numbers, `{p}` and `{q}`, to solve this. Typically, the most time consuming phase is this phase, especially if `{n}` is a large number. As in the challenge description, we are told that "Generating primes is too hard, but I did find a couple posted online!" namely by using factorization tools available online, such as [FactorDB](http://factordb.com).

Once we get the factor `n`. Here's a possible step to check whether `p` and `q` are indeed factors of `n`.

```python
n = 23690620655271165329693230765997410033604713853187305472268813793031152348107488119317901392104240429826482611449247251262846508667797483465355228800439339041030982259847598574606272955688345490638311164838117491821117626835340577511562130640807587611523935604871183668968359720411023759980144229161581597397061850707647104033348795132205561234674677139395868595692235525931999596382758921793937149945229459379437008216713404350896206374483356969246476531491049930769999387038678280465689487577291475554699094024761030833540509263174840007922218340417888061099317752496279552046029470370474619439450870110783844218281
p = 136883787266364340043941875346794871076915042034415471498906549087728253259343034107810407965879553240797103876807324140752463772912574744029721362424045513479264912763274224483253555686223222977433620164528749150128078791978059487880374953312009335263406691102746179899587617728126307533778214066506682031517
q = 173071049014527992115134608840044450224804187710129859708853805709176487316207010402251651554296674942983458628001825388092613984020357016543095854903752286499436288875811897772811421580394898931781960982007306544027009178109074133665714245347548210688178519450728052309689045110008994598784658702110905581693

if p * q == n:
    print("p * q == n")
else:
    print("p * q != n")
```

Final solver:

```python {title="solver.py" lineNos=true lineNoStart=1}
from Crypto.Util.number import inverse, long_to_bytes

# given values
n = 23690620655271165329693230765997410033604713853187305472268813793031152348107488119317901392104240429826482611449247251262846508667797483465355228800439339041030982259847598574606272955688345490638311164838117491821117626835340577511562130640807587611523935604871183668968359720411023759980144229161581597397061850707647104033348795132205561234674677139395868595692235525931999596382758921793937149945229459379437008216713404350896206374483356969246476531491049930769999387038678280465689487577291475554699094024761030833540509263174840007922218340417888061099317752496279552046029470370474619439450870110783844218281
e = 65537
ct = 11420169733597912638453974310976296342840438772934899653944946284527921765463891354182152294616337665313108085636067061251485792996493148094827999964385583364992542843630846911864602981658349693548380259629884212903554470004231160866680745154066318419977485221228944716844036265911222656710479650139274719426252576406561307088938784324291655853920727176132853663822020880574204790442647169649094846806057218165102873847070323190392619997632103724159815363319643022552432448214770378596825200154298562513279104608157870845848578603703757405758227316242247843290673221718467366000253484278487854736033323783510299081405

# factorized {n} with factordb.com
p = 136883787266364340043941875346794871076915042034415471498906549087728253259343034107810407965879553240797103876807324140752463772912574744029721362424045513479264912763274224483253555686223222977433620164528749150128078791978059487880374953312009335263406691102746179899587617728126307533778214066506682031517
q = 173071049014527992115134608840044450224804187710129859708853805709176487316207010402251651554296674942983458628001825388092613984020357016543095854903752286499436288875811897772811421580394898931781960982007306544027009178109074133665714245347548210688178519450728052309689045110008994598784658702110905581693

phi = (p - 1) * (q - 1)
d = inverse(e, phi)
m = pow(ct, d, n)

message = long_to_bytes(m)
print(message)
```

```bash
$ python3 solve.py
b'squ1rrel{laziness_will_be_the_answer_eventually}'
```

<details>
  <summary>FLAG</summary>
  
  > `squ1rrel{laziness_will_be_the_answer_eventually}`
    
</details>

<br>

### RSA RSA RSA

<details>
  <summary>Overview</summary>

  > Description: I had something so important to say that I just had to tell three of my friends!  <br>
  
  [rsarsarsa.txt](https://github.com/nopedawn/CTF/main/squ1rrelCTF24/RSA_RSA_RSA/rsarsarsa.txt) <br>

</details>

This one is a RSA Chinese Remainder Theorem (CRT) challenge. From the provided chall source, we given three ciphertexts and three moduli, all encrypted with the same exponent `{e}`.

```yml
e: 3
n1: 96137714481560340073780038250015316564930752333880363375193088083653975552334517899735106334409092229494004991796910602440032630762575914714152238916128674595912438177270978040111855327624812652948702562503276973409716595778936978757384935820012322432156169815110042972411989274515686945691887468406312791931
ct1: 45640508926729498938915879450220374487095109122207451961200230820161694723491945276893630019713859109920025191680053056485030809079137883906737197875968862878423820820515399840094772412319820062860149582361429346029277273870654355752499436360499181221418835401103925420623212341317366954144592892392013649421
n2: 90990790933807553440094447797505116528289571569256574363585309090304380702927241663491819956599368816997683603352289726407304960362149545383683196526764288524742203975596414405902155486632888712453606841629050125783639571606440840246928825545860143096340538904060826483178577619093666337611264852255012241011
ct2: 58149644956871439128498229750735120049939213159976216414725780828349070974351356297226894029560865402164610877553706310307735037479690463594397903663323983980128060190648604447657636452565715178438939334318494616246072096228912870579093620604596752844583453865894005036516299903524382604570097012992290786402
n3: 86223965871064436340735834556059627182534224217231808576284808010466364412704836149817574186647031512768701943310184993378236691990480428328117673064942878770269493388776005967773324771885109757090215809598845563135795831857972778498394289917587876390109949975194987996902591291672194435711308385660176310561
ct3: 16168828246411344105159374934034075195568461748685081608380235707338908077276221477034184557590734407998991183114724523494790646697027318500705309235429037934125253625837179003478944984233647083364969403257234704649027075136139224424896295334075272153594459752240304700899700185954651799042218888117178057955
```

By combining these equations and solving for the plaintext message, the solution makes use of the CRT. Here's how to do it:

```python {title="solver.py" lineNos=true lineNoStart=1}
from sympy import *
from Crypto.Util.number import long_to_bytes

# given values
e = 3
n1 = 96137714481560340073780038250015316564930752333880363375193088083653975552334517899735106334409092229494004991796910602440032630762575914714152238916128674595912438177270978040111855327624812652948702562503276973409716595778936978757384935820012322432156169815110042972411989274515686945691887468406312791931
ct1 = 45640508926729498938915879450220374487095109122207451961200230820161694723491945276893630019713859109920025191680053056485030809079137883906737197875968862878423820820515399840094772412319820062860149582361429346029277273870654355752499436360499181221418835401103925420623212341317366954144592892392013649421
n2 = 90990790933807553440094447797505116528289571569256574363585309090304380702927241663491819956599368816997683603352289726407304960362149545383683196526764288524742203975596414405902155486632888712453606841629050125783639571606440840246928825545860143096340538904060826483178577619093666337611264852255012241011
ct2 = 58149644956871439128498229750735120049939213159976216414725780828349070974351356297226894029560865402164610877553706310307735037479690463594397903663323983980128060190648604447657636452565715178438939334318494616246072096228912870579093620604596752844583453865894005036516299903524382604570097012992290786402
n3 = 86223965871064436340735834556059627182534224217231808576284808010466364412704836149817574186647031512768701943310184993378236691990480428328117673064942878770269493388776005967773324771885109757090215809598845563135795831857972778498394289917587876390109949975194987996902591291672194435711308385660176310561
ct3 = 16168828246411344105159374934034075195568461748685081608380235707338908077276221477034184557590734407998991183114724523494790646697027318500705309235429037934125253625837179003478944984233647083364969403257234704649027075136139224424896295334075272153594459752240304700899700185954651799042218888117178057955

# compute N = n1*n2*n3
N = n1*n2*n3

# compute Ni and yi for i in {1,2,3}
N1 = N // n1
y1 = pow(N1, -1, n1)
N2 = N // n2
y2 = pow(N2, -1, n2)
N3 = N // n3
y3 = pow(N3, -1, n3)

# compute m^3 using CRT
m_cubed = (ct1*N1*y1 + ct2*N2*y2 + ct3*N3*y3) % N

# compute m by taking cube root of m^3
m = root(m_cubed, 3)

flag = long_to_bytes(m)

print(flag)
```

```bash
$ python3 solve.py
b'squ1rrel{math_is_too_powerful_1q3y41t1s98u23rf8}'
```

<details>
  <summary>FLAG</summary>
  
  > `squ1rrel{math_is_too_powerful_1q3y41t1s98u23rf8}`
    
</details>


<br>
<hr>

## Misc

### rainbolt0

<details>
  <summary>Overview</summary>

  > Description: Once you've tracked down the location find it on here: https://what3words.com/ and submit as the flag  <br> example: squ1rrel{painting.impact.picture} <br>
  
  [rainbolt0.png](https://github.com/nopedawn/CTF/main/squ1rrelCTF24/rainbolt0/rainbolt0.png) <br>

</details>

Soon..

<details>
  <summary>FLAG</summary>
  
  > `FLAG`
    
</details>


<br>
<hr>

## Rev

### Secret Coffee Nut Stash

<details>
  <summary>Overview</summary>

  > Description: You'll never be able to break into my secret Java coffee nut stash! <br>
  
  [CoffeNutStash.class](https://github.com/nopedawn/CTF/main/squ1rrelCTF24/Secret_Coffee_Nut_Stash/CoffeNutStash.class) <br>

</details>

Soon..

<details>
  <summary>FLAG</summary>
  
  > `FLAG`
    
</details>

<br>

### PYC Fun

<details>
  <summary>Overview</summary>

  > Description: Have fun with this PYC <br>
  
  [pyc_fun.pyc](https://github.com/nopedawn/CTF/main/squ1rrelCTF24/PYC_Fun/pyc_fun.pyc) <br>

</details>

Soon..

<details>
  <summary>FLAG</summary>
  
  > `FLAG`
    
</details>